"""
Tests autonomes des am√©liorations SophIA
Version compl√®te sans d√©pendances externes
"""

import sys
import os

# Configuration des imports
ROOT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, ROOT_DIR)

# Utilitaires de test int√©gr√©s (pas d'import externe)
def assert_valid_response(response, min_length=10):
    """V√©rifie qu'une r√©ponse SophIA est valide"""
    assert response is not None
    assert hasattr(response, 'natural_response')
    assert hasattr(response, 'conceptual_analysis')
    assert len(response.natural_response) >= min_length
    assert 'concepts_detected' in response.conceptual_analysis

def assert_concepts_detected(response, expected_concepts, min_match=1):
    """V√©rifie que les concepts attendus sont d√©tect√©s"""
    detected = response.conceptual_analysis.get('concepts_detected', [])
    matches = sum(1 for concept in expected_concepts if concept in detected)
    assert matches >= min_match, f"Expected at least {min_match} concepts from {expected_concepts}, got {detected}"

def measure_response_time(func, *args, **kwargs):
    """Mesure le temps de r√©ponse d'une fonction"""
    import time
    start = time.time()
    result = func(*args, **kwargs)
    end = time.time()
    return result, end - start

def test_concept_bridge():
    """Teste le pont conceptuel am√©lior√©"""
    print("üîó Test du Concept Bridge...")
    
    try:
        from sophia.bridge.concept_text_bridge import EnhancedConceptTextBridge
        from sophia.core.ontology import SimpleOntology
        from sophia.llm.llama_interface import OllamaLLaMAInterface
        
        ontology = SimpleOntology()
        llm = OllamaLLaMAInterface()
        bridge = EnhancedConceptTextBridge(ontology, llm)
        
        # Test d'initialisation
        assert bridge.ontology is not None
        assert bridge.llm is not None
        assert len(bridge.concept_patterns) > 0
        print("  ‚úÖ Initialisation r√©ussie")
        
        # Test des synonymes am√©lior√©s
        print("  üîç Test g√©n√©ration synonymes...")
        synonyms = bridge._get_concept_synonyms('V√âRIT√â')
        assert isinstance(synonyms, list)
        assert len(synonyms) > 0
        print(f"  ‚úÖ Synonymes pour V√âRIT√â: {synonyms[:5]}...")
        
        # Test de l'extraction am√©lior√©e
        print("  üîç Test extraction am√©lior√©e...")
        test_text = "La v√©rit√© philosophique est-elle relative √† notre perception de la justice ?"
        base_extraction = {'concepts_detected': ['V√âRIT√â'], 'confidence': 0.8}
        
        enhanced = bridge.enhanced_concept_extraction(test_text, base_extraction)
        
        assert 'enhanced_confidence' in enhanced
        assert 'concept_matches' in enhanced
        assert 'concepts_detailed' in enhanced
        assert 0.0 <= enhanced['enhanced_confidence'] <= 1.0
        
        print(f"  ‚úÖ Concepts d√©tect√©s: {enhanced['concepts_detected']}")
        print(f"  ‚úÖ Confiance am√©lior√©e: {enhanced['enhanced_confidence']:.2f}")
        
        return True
        
    except Exception as e:
        print(f"  ‚ùå Erreur Bridge: {e}")
        import traceback
        traceback.print_exc()
        return False

def test_constraint_manager():
    """Teste le gestionnaire de contraintes"""
    print("\n‚öñÔ∏è Test du Constraint Manager...")
    
    try:
        from sophia.constraints.constraint_manager import PhilosophicalConstraintManager
        from sophia.core.ontology import SimpleOntology
        from sophia.llm.llama_interface import OllamaLLaMAInterface
        
        ontology = SimpleOntology()
        llm = OllamaLLaMAInterface()
        constraint_manager = PhilosophicalConstraintManager(ontology, llm)
        
        # Test d'initialisation
        assert constraint_manager.ontology is not None
        assert constraint_manager.llm is not None
        assert len(constraint_manager.constraints) > 0
        assert len(constraint_manager.philosophical_clusters) > 0
        print("  ‚úÖ Initialisation r√©ussie")
        
        # Test des clusters philosophiques
        clusters = constraint_manager.philosophical_clusters
        cluster_names = [c['name'] for c in clusters]
        
        expected_clusters = ['√âpist√©mologie', '√âthique', 'M√©taphysique']
        found_clusters = [name for name in expected_clusters if name in cluster_names]
        
        print(f"  ‚úÖ Clusters trouv√©s: {found_clusters}")
        print(f"  ‚úÖ Total clusters: {len(clusters)}")
        
        # Test de validation
        print("  üîç Test validation r√©ponse...")
        test_response = """La v√©rit√© est un concept philosophique fondamental. 
        Tout d'abord, elle peut √™tre consid√©r√©e comme absolue selon Platon. 
        Ensuite, elle peut √™tre relative selon les sophistes. 
        Enfin, elle d√©pend de notre capacit√© √† conna√Ætre la r√©alit√©."""
        
        test_context = {
            'concepts_detected': ['V√âRIT√â', 'CONNAISSANCE'],
            'question': 'Qu\'est-ce que la v√©rit√© ?'
        }
        
        validation = constraint_manager.validate_response(test_response, test_context)
        
        assert 'global_score' in validation
        assert 'constraint_results' in validation
        assert 'is_valid' in validation
        assert 0.0 <= validation['global_score'] <= 1.0
        
        print(f"  ‚úÖ Score global: {validation['global_score']:.2f}")
        print(f"  ‚úÖ Contraintes actives: {len(constraint_manager.constraints)}")
        print(f"  ‚úÖ Validation r√©ussie: {validation['is_valid']}")
        
        if validation.get('recommendations'):
            print(f"  üí° Recommandations: {len(validation['recommendations'])}")
        
        return True
        
    except Exception as e:
        print(f"  ‚ùå Erreur Constraints: {e}")
        import traceback
        traceback.print_exc()
        return False

def test_enhanced_sophia():
    """Teste SophIA avec les am√©liorations"""
    print("\nüß† Test de SophIA Enhanced...")
    
    try:
        from sophia.core.sophia_hybrid import HybridSophIA
        
        print("  üöÄ Initialisation...")
        sophia = HybridSophIA(session_name="test_enhanced", auto_save=False)
        
        # V√©rifications d'initialisation
        assert hasattr(sophia, 'concept_bridge')
        assert hasattr(sophia, 'constraint_manager')
        assert sophia.concept_bridge is not None
        assert sophia.constraint_manager is not None
        
        print("  ‚úÖ SophIA Enhanced initialis√©e !")
        print(f"  üìö Ontologie: {len(sophia.ontology.concepts)} concepts")
        print(f"  üîó Bridge actif: True")
        print(f"  ‚öñÔ∏è Constraint manager actif: True")
        
        # Test de conversation
        print("\n  üí¨ Test de conversation...")
        questions = [
            "Qu'est-ce que la v√©rit√© ?",
            "La justice peut-elle √™tre absolue ?"
        ]
        
        for i, question in enumerate(questions, 1):
            print(f"\n  üìù Question {i}: {question}")
            
            response = sophia.ask(question)
            
            # V√©rifications de base
            assert_valid_response(response, min_length=30)
            assert hasattr(response, 'validation_report')
            assert response.confidence > 0.0
            
            print(f"    üß† R√©ponse: {response.natural_response[:100]}...")
            
            concepts = response.conceptual_analysis.get('concepts_detected', [])
            print(f"    üí° Concepts: {concepts}")
            print(f"    üéØ Confiance: {response.confidence:.2f}")
            
            if 'global_score' in response.validation_report:
                print(f"    üìä Score validation: {response.validation_report['global_score']:.2f}")
        
        # Test du raisonnement d√©taill√©
        print("\n  üîç Test d'explication du raisonnement:")
        explanation = sophia.explain_reasoning("Qu'est-ce que la justice ?")
        
        required_steps = ['step1_concept_detection', 'step2_conceptual_reasoning', 
                         'step3_constraint_validation', 'step4_synthesis']
        
        for step in required_steps:
            assert step in explanation, f"√âtape manquante: {step}"
        
        print(f"    ‚úÖ Toutes les √©tapes pr√©sentes: {len(required_steps)}")
        print(f"    - M√©thode: {explanation['step1_concept_detection']['method']}")
        
        if 'concepts_found' in explanation['step1_concept_detection']:
            concepts_found = explanation['step1_concept_detection']['concepts_found']
            print(f"    - Concepts trouv√©s: {concepts_found}")
        
        # Test du r√©sum√© am√©lior√©
        print("\n  üìä Test du r√©sum√© de conversation:")
        summary = sophia.get_conversation_summary()
        
        assert 'total_interactions' in summary
        assert 'average_confidence' in summary
        
        print(f"    - Interactions: {summary['total_interactions']}")
        print(f"    - Confiance moyenne: {summary['average_confidence']:.2f}")
        
        if 'system_performance' in summary:
            perf = summary['system_performance']
            print(f"    - Bridge actif: {perf.get('concept_bridge_active', 'N/A')}")
            print(f"    - Constraints actifs: {perf.get('constraint_manager_active', 'N/A')}")
        
        return True
        
    except Exception as e:
        print(f"  ‚ùå Erreur SophIA Enhanced: {e}")
        import traceback
        traceback.print_exc()
        return False

def test_performance():
    """Teste les performances"""
    print("\n‚ö° Test de Performance...")
    
    try:
        from sophia.core.sophia_hybrid import HybridSophIA
        
        sophia = HybridSophIA(session_name="test_perf", auto_save=False)
        
        question = "Qu'est-ce que la v√©rit√© ?"
        print(f"  üîç Test avec question: {question}")
        
        response, duration = measure_response_time(sophia.ask, question)
        
        assert_valid_response(response)
        print(f"  ‚úÖ Temps de r√©ponse: {duration:.2f}s")
        
        # √âvaluation performance
        if duration < 10.0:
            print(f"  üöÄ Performance excellente (< 10s)")
        elif duration < 30.0:
            print(f"  ‚úÖ Performance acceptable (< 30s)")
        else:
            print(f"  ‚ö†Ô∏è Performance lente (> 30s)")
        
        return True
        
    except Exception as e:
        print(f"  ‚ùå Erreur Performance: {e}")
        import traceback
        traceback.print_exc()
        return False

def main():
    """Test principal"""
    print("üß™ TESTS DES AM√âLIORATIONS SOPHIA")
    print("=" * 60)
    
    tests = [
        ("Concept Bridge", test_concept_bridge),
        ("Constraint Manager", test_constraint_manager),
        ("SophIA Enhanced", test_enhanced_sophia),
        ("Performance", test_performance)
    ]
    
    results = []
    
    for test_name, test_func in tests:
        print(f"\nüöÄ Test: {test_name}")
        print("-" * 40)
        
        try:
            success = test_func()
            results.append((test_name, success))
            
        except Exception as e:
            print(f"üí• {test_name}: ERREUR FATALE - {e}")
            import traceback
            traceback.print_exc()
            results.append((test_name, False))
    
    # R√©sum√© final
    print("\n" + "=" * 60)
    print("üìä R√âSUM√â DES TESTS")
    print("-" * 30)
    
    passed = sum(1 for _, success in results if success)
    total = len(results)
    
    for test_name, success in results:
        status = "‚úÖ R√âUSSI" if success else "‚ùå √âCHOU√â"
        print(f"{test_name:<20} {status}")
    
    print(f"\nüéØ SCORE FINAL: {passed}/{total} tests r√©ussis ({passed/total*100:.0f}%)")
    
    if passed == total:
        print("\nüéâ TOUTES LES AM√âLIORATIONS FONCTIONNENT PARFAITEMENT !")
        print("\nüöÄ Prochaines √©tapes:")
        print("1. Lance: python simple_interface.py")
        print("2. Lance: python launch_web.py") 
        print("3. Teste avec des questions complexes!")
        print("4. Observe les am√©liorations (synonymes, validation, etc.)")
    elif passed > 0:
        print(f"\n‚úÖ {passed} am√©liorations fonctionnent, {total-passed} ont des probl√®mes.")
        print("V√©rifiez les erreurs ci-dessus pour les corriger.")
    else:
        print("\n‚ùå Aucune am√©lioration ne fonctionne.")
        print("V√©rifiez que les fichiers sont bien cr√©√©s et les imports corrects.")
    
    return passed == total

if __name__ == '__main__':
    success = main()
    print(f"\n{'üéâ SUCC√àS' if success else '‚ö†Ô∏è √âCHEC'} - Test termin√©")